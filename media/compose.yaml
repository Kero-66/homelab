# =============================================================================
# Media Stack - Docker Compose Configuration
# =============================================================================
# Complete media server stack with *arr apps, download clients, and media servers.
#
# Usage:
#   docker compose up -d                    # Start all services (no VPN)
#   docker compose --profile vpn up -d      # Start with VPN enabled
#   docker compose --profile jellyfin up -d # Start with Jellyfin stack
#   docker compose --profile all up -d      # Start everything
#
# Configuration Paths:
#   CONFIG_DIR: Where service configs are stored (default: . = current directory)
#               For production, set to /opt/docker/media or similar
#   DATA_DIR:   Where media files are stored (default: /data)
#
# All containers use PUID/PGID from .env for consistent file permissions.
#
# See: https://github.com/TechHutTV/homelab/tree/main/media#docker-compose-and-env
# =============================================================================

x-common: &media-common
  # Shared settings for homepage; env files listed with the shared file first so local vars override
  env_file:
    # - ../../media/.env
    - .config/.credentials
    - .env
  restart: "${RESTART_POLICY}"
  profiles: ["media", "all"]

networks:
  servarrnetwork:
    name: servarrnetwork
    ipam:
      config:
        - subnet: ${SERVARR_SUBNET:-172.39.0.0/24}

services:
  # ===========================================================================
  # VPN Container (Optional - use --profile vpn)
  # ===========================================================================
  # AirVPN recommended: https://airvpn.org/?referred_by=673908
  # gluetun:
  #   image: qmcgaw/gluetun
  #   container_name: gluetun
  #   profiles: ["vpn", "all"]
  #   cap_add:
  #     - NET_ADMIN
  #   devices:
  #     - /dev/net/tun:/dev/net/tun
  #   networks:
  #     servarrnetwork:
  #       ipv4_address: 172.39.0.250
  #   ports:
  #     # When VPN is enabled, these services route through gluetun
  #     - ${QBIT_WEBUI_PORT:-8080}:8080
  #     - ${QBIT_TORRENT_PORT_TCP:-6881}:6881/tcp
  #     - ${QBIT_TORRENT_PORT_UDP:-6881}:6881/udp
  #     - ${NZBGET_PORT:-6789}:6789
  #   volumes:
  #     - ${CONFIG_DIR:-.}/gluetun:/gluetun
  #   env_file:
  #     - .env
  #   healthcheck:
  #     test: ping -c 1 www.google.com || exit 1
  #     interval: 30s
  #     timeout: 10s
  #     retries: 5
  #   restart: unless-stopped

  qbittorrent:
    image: lscr.io/linuxserver/qbittorrent:latest
    container_name: qbittorrent
    restart: unless-stopped
    mem_limit: 512m
    # labels:
    #   - deunhealth.restart.on.unhealthy=true
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - WEBUI_PORT=8080 # must match "qbittorrent web interface" port number in gluetun's service above
    #  - TORRENTING_PORT=${FIREWALL_VPN_INPUT_PORTS} # airvpn forwarded port, pulled from .env
    volumes:
      - ${CONFIG_DIR:-.}/qbittorrent:/config
      - ${DATA_DIR:-/data}:/data
    # depends_on:
    #   gluetun:
    #     condition: service_healthy
    #     restart: true
    # network_mode: service:gluetun
    ports:
      - ${QBIT_WEBUI_PORT:-8080}:8080
      - ${QBIT_TORRENT_PORT_TCP:-6881}:6881/tcp
      - ${QBIT_TORRENT_PORT_UDP:-6881}:6881/udp
    networks:
      servarrnetwork:
        ipv4_address: ${IP_QBITTORRENT:-172.39.0.12}
    healthcheck:
      test: curl -sf http://localhost:8080 || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  # See the 'qBittorrent Stalls with VPN Timeout' section for more information.

  # COMMENTED OUT FOR LOCAL TESTING
  # deunhealth:
  #   image: qmcgaw/deunhealth
  #   container_name: deunhealth
  #   network_mode: "none"
  #   environment:
  #     - LOG_LEVEL=info
  #     - HEALTH_SERVER_ADDRESS=127.0.0.1:9999
  #     - TZ=${TZ}
  #   restart: always
  #   volumes:
  #     - /var/run/docker.sock:/var/run/docker.sock

  sabnzbd:
    image: lscr.io/linuxserver/sabnzbd:latest
    container_name: sabnzbd
    mem_limit: 512m
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - ${CONFIG_DIR:-.}/sabnzbd:/config
      - ${DATA_DIR:-/data}:/data
    restart: unless-stopped
    ports:
      - ${SABNZBD_PORT:-8085}:8080
    networks:
      servarrnetwork:
        ipv4_address: ${IP_SABNZBD:-172.39.0.24}
    healthcheck:
      test: ["CMD-SHELL", "curl -s http://localhost:8080/ > /dev/null || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  nzbget:
    image: lscr.io/linuxserver/nzbget:latest
    container_name: nzbget
    mem_limit: 512m
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - NZBGET_USER=${NZBGET_USER}
      - NZBGET_PASS=${NZBGET_PASS}
    volumes:
      - ${CONFIG_DIR:-.}/nzbget:/config
      - ${DATA_DIR:-/data}:/data
    restart: unless-stopped
    ports:
      - ${NZBGET_PORT:-6789}:6789
    networks:
      servarrnetwork:
        ipv4_address: ${IP_NZBGET:-172.39.0.7}
    healthcheck:
      test: curl -sf http://localhost:6789 || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  # FlareSolverr helps bypass Cloudflare protection on indexers
  # Required for many indexers when running without VPN
  flaresolverr:
    image: ghcr.io/flaresolverr/flaresolverr:latest
    container_name: flaresolverr
    mem_limit: 256m
    environment:
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - LOG_HTML=${LOG_HTML:-false}
      - CAPTCHA_SOLVER=${CAPTCHA_SOLVER:-none}
      - TZ=${TZ}
    # Use public DNS servers
    dns:
      - 1.1.1.1
      - 8.8.8.8
    ports:
      - ${FLARESOLVERR_PORT:-8191}:8191
    networks:
      servarrnetwork:
        ipv4_address: ${IP_FLARESOLVERR:-172.39.0.9}
    restart: unless-stopped
    healthcheck:
      test: curl -sf http://localhost:8191/health || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  prowlarr:
    image: lscr.io/linuxserver/prowlarr:latest
    container_name: prowlarr
    mem_limit: 512m
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    # Use public DNS servers to resolve indexer domains without VPN
    dns:
      - 1.1.1.1      # Cloudflare DNS
      - 8.8.8.8      # Google DNS
    volumes:
      - ${CONFIG_DIR:-.}/prowlarr:/config
    restart: unless-stopped
    # depends_on:
    #   gluetun:
    #     condition: service_healthy
    #     restart: true
    # network_mode: service:gluetun
    ports:
      - ${PROWLARR_PORT:-9696}:9696
    networks:
      servarrnetwork:
        ipv4_address: ${IP_PROWLARR:-172.39.0.8}
    healthcheck:
      test: curl -sf http://localhost:9696/ping || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  sonarr:
    image: lscr.io/linuxserver/sonarr:latest
    container_name: sonarr
    restart: unless-stopped
    mem_limit: 512m
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - ${CONFIG_DIR:-.}/sonarr:/config
      - ${DATA_DIR:-/data}:/data
    ports:
      - ${SONARR_PORT:-8989}:8989
    networks:
      servarrnetwork:
        ipv4_address: ${IP_SONARR:-172.39.0.3}
    healthcheck:
      test: curl -sf http://localhost:8989/ping || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  radarr:
    image: lscr.io/linuxserver/radarr:latest
    container_name: radarr
    restart: unless-stopped
    mem_limit: 512m
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - ${CONFIG_DIR:-.}/radarr:/config
      - ${DATA_DIR:-/data}:/data
    ports:
      - ${RADARR_PORT:-7878}:7878
    networks:
      servarrnetwork:
        ipv4_address: ${IP_RADARR:-172.39.0.4}
    healthcheck:
      test: curl -sf http://localhost:7878/ping || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
  # lidarr: (commented out)
  #   container_name: lidarr
  #   image: lscr.io/linuxserver/lidarr:latest
  #   restart: unless-stopped
  #   mem_limit: 512m
  #   volumes:
  #     - ${CONFIG_DIR:-.}/lidarr:/config
  #     - ${DATA_DIR:-/data}:/data
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #     - TZ=${TZ}
  #   ports:
  #     - ${LIDARR_PORT:-8686}:8686
  #   networks:
  #     servarrnetwork:
  #       ipv4_address: ${IP_LIDARR:-172.39.0.5}
  #   healthcheck:
  #     test: curl -sf http://localhost:8686/ping || exit 1
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 30s

  bazarr:
    image: lscr.io/linuxserver/bazarr:latest
    container_name: bazarr
    restart: unless-stopped
    mem_limit: 256m
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - ${CONFIG_DIR:-.}/bazarr:/config
      - ${DATA_DIR:-/data}:/data
    ports:
      - ${BAZARR_PORT:-6767}:6767
    networks:
      servarrnetwork:
        ipv4_address: ${IP_BAZARR:-172.39.0.6}
    healthcheck:
      test: curl -sf http://localhost:6767/ || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  # ===========================================================================
  # Jellyfin Stack (Optional - use --profile jellyfin or --profile all)
  # ===========================================================================

  jellyfin:
    image: lscr.io/linuxserver/jellyfin:latest
    container_name: jellyfin
    profiles: ["jellyfin", "all"]
    restart: unless-stopped
    mem_limit: 2g
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - ${CONFIG_DIR:-.}/jellyfin/config:/config
      - ${DATA_DIR:-/data}:/data
    # Hardware acceleration - uncomment for Intel QuickSync
    # devices:
    #   - /dev/dri:/dev/dri
    ports:
      - ${JELLYFIN_PORT:-8096}:8096
      - ${JELLYFIN_DISCOVERY_PORT:-7359}:7359/udp
      - 1900:1900/udp
    networks:
      servarrnetwork:
        ipv4_address: ${IP_JELLYFIN:-172.39.0.10}
    healthcheck:
      test: curl -sf http://localhost:8096/health || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  jellyseerr:
    image: fallenbagel/jellyseerr:latest
    container_name: jellyseerr
    profiles: ["jellyfin", "all"]
    restart: unless-stopped
    mem_limit: 512m
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - ${CONFIG_DIR:-.}/jellyfin/jellyseerr:/app/config
    ports:
      - ${JELLYSEERR_PORT:-5055}:5055
    networks:
      servarrnetwork:
        ipv4_address: ${IP_JELLYSEERR:-172.39.0.11}
    healthcheck:
      test: wget -q --spider http://localhost:5055/api/v1/status || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  jellystat-db:
    image: postgres:15
    container_name: jellystat-db
    profiles: ["jellyfin", "all"]
    restart: unless-stopped
    mem_limit: 256m
    environment:
      - POSTGRES_USER=${JELLYSTAT_DB_USER}
      - POSTGRES_PASSWORD=${JELLYSTAT_DB_PASS}
    volumes:
      - ${CONFIG_DIR:-.}/jellyfin/jellystat/postgres:/var/lib/postgresql/data
    networks:
      servarrnetwork:
        ipv4_address: ${IP_JELLYSTAT_DB:-172.39.0.13}
    healthcheck:
      test: pg_isready -U ${JELLYSTAT_DB_USER}
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  jellystat:
    image: cyfershepard/jellystat:latest
    container_name: jellystat
    profiles: ["jellyfin", "all"]
    restart: unless-stopped
    mem_limit: 256m
    environment:
      - POSTGRES_USER=${JELLYSTAT_DB_USER}
      - POSTGRES_PASSWORD=${JELLYSTAT_DB_PASS}
      - POSTGRES_IP=jellystat-db
      - POSTGRES_PORT=5432
      - JWT_SECRET=${JELLYSTAT_JWT_SECRET}
      - TZ=${TZ}
    volumes:
      - ${CONFIG_DIR:-.}/jellyfin/jellystat/backup-data:/app/backend/backup-data
    ports:
      - ${JELLYSTAT_PORT:-3002}:3000
    networks:
      servarrnetwork:
        ipv4_address: ${IP_JELLYSTAT:-172.39.0.14}
    depends_on:
      jellystat-db:
        condition: service_healthy
    healthcheck:
      test: wget -q --spider http://localhost:3002 || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s


  # ===========================================================================
  # Ombi - Manga/Anime Request Interface (like Jellyseerr for manga through Sonarr)
  # Service commented out per user request.
  # ombi:
  #   image: lscr.io/linuxserver/ombi:latest
  #   container_name: ombi
  #   restart: unless-stopped
  #   mem_limit: 512m
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #     - TZ=${TZ}
  #   volumes:
  #     - ${CONFIG_DIR:-.}/ombi:/config
  #   ports:
  #     - 8000:3579
  #   networks:
  #     servarrnetwork:
  #       ipv4_address: ${IP_OMBI:-172.39.0.20}
  #   healthcheck:
  #     test: curl -sf http://localhost:3579 || exit 1
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 30s


  # ubooquity: (commented out)
  #   image: lscr.io/linuxserver/ubooquity:latest
  #   container_name: ubooquity
  #   profiles: ["all"]
  #   restart: unless-stopped
  #   mem_limit: 256m
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #     - TZ=${TZ}
  #   volumes:
  #     - ${CONFIG_DIR:-.}/ubooquity:/config
  #     - ${DATA_DIR:-/data}:/books
  #   ports:
  #     - ${UBOOQUIITY_PORT:-2202}:2202
  #   networks:
  #     servarrnetwork:
  #       ipv4_address: ${IP_UBOOQUIITY:-172.39.0.18}
  #   healthcheck:
  #     test: curl -sf http://localhost:2202/ubooquity/ || exit 1
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 30s

  # mylar3: (commented out)
  #   image: lscr.io/linuxserver/mylar3:latest
  #   container_name: mylar3
  #   profiles: ["all"]
  #   restart: unless-stopped
  #   mem_limit: 512m
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #     - TZ=${TZ}
  #   volumes:
  #     - ${CONFIG_DIR:-.}/mylar3:/config
  #     - ${DATA_DIR:-/data}:/data
  #   ports:
  #     - ${MYLAR3_PORT:-8090}:8090
  #   networks:
  #     servarrnetwork:
  #       ipv4_address: ${IP_MY3:-172.39.0.19}
  #   healthcheck:
  #     test: |
  #       curl -sf -u "${MYLAR3_USER:-}:${MYLAR3_PASS:-}" http://localhost:8090/ || exit 1
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 30s

  # ===========================================================================
  # Optional Services (uncomment to enable)
  # ===========================================================================


  # ytdl-sub:
  #   image: ghcr.io/jmbannon/ytdl-sub:latest
  #   container_name: ytdl-sub
  #   environment:
  #     - PUID=${PUID}
  #     - PGID=${PGID}
  #     - TZ=${TZ}
  #     - DOCKER_MODS=linuxserver/mods:universal-cron
  #   volumes:
  #     - ./ytdl-sub:/config
  #     - ${DATA_DIR:-/data}/youtube:/youtube
  #   networks:
  #     servarrnetwork:
  #   restart: unless-stopped

  # Huntarr (optional) - enable by setting image/port in .env and leaving uncommented
  huntarr:
    image: ghcr.io/plexguide/huntarr:latest
    container_name: huntarr
    restart: unless-stopped
    mem_limit: 256m
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - ${CONFIG_DIR:-.}/huntarr:/config
      - ${DATA_DIR:-/data}:/data
    ports:
      - ${HUNTARR_PORT:-9705}:9705
    networks:
      servarrnetwork:
        ipv4_address: ${IP_HUNTARR:-172.39.0.21}
    healthcheck:
      test: curl -sf http://localhost:9705/ || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  # CleanupArr (optional) - enable by setting image/port in .env and leaving uncommented
  cleanuparr:
    image: ghcr.io/cleanuparr/cleanuparr:latest
    container_name: cleanuparr
    restart: unless-stopped
    mem_limit: 256m
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - ${CONFIG_DIR:-.}/cleanuparr:/config
      - ${DATA_DIR:-/data}:/data
    ports:
      - ${CLEANUPARR_PORT:-11011}:11011
    networks:
      servarrnetwork:
        ipv4_address: ${IP_CLEANUPARR:-172.39.0.22}
    healthcheck:
      test: curl -sf http://localhost:11011/ || exit 1
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  recyclarr:
    image: recyclarr/recyclarr:latest
    container_name: recyclarr
    restart: unless-stopped
    user: ${PUID:-1000}:${PGID:-1000}
    profiles: ["media", "all"]
    environment:
      - TZ=${TZ}
      - CRON_SCHEDULE=@daily
    volumes:
      - ${CONFIG_DIR:-.}/recyclarr/config:/config
    networks:
      servarrnetwork:
        ipv4_address: ${IP_RECYCLARR:-172.39.0.25}

  media-provisioner:
    image: python:3.12-slim
    container_name: media-provisioner
    profiles: ["all"]
    restart: "no"
    volumes:
      - ./scripts:/workdir/scripts:ro
      - ./sonarr:/workdir/sonarr:ro
      - ./radarr:/workdir/radarr:ro
      - ./lidarr:/workdir/lidarr:ro
      - ./prowlarr:/workdir/prowlarr:ro
      - ./mylar3:/workdir/mylar3:rw
      - ./.env:/workdir/.env:ro
    working_dir: /workdir
    <<: *media-common
    command: ["bash", "-c", "apt-get update >/dev/null && apt-get install -y curl >/dev/null && /workdir/scripts/provision_comics.sh"]
    depends_on:
      prowlarr:
        condition: service_started
      qbittorrent:
        condition: service_started

